<html>
	<head>
		<title>Beyond</title>
		<link rel="icon" href="">
		<style>
			body {
				background-color: black;
				margin: 0 0 0 0;
			}
			div {
				display: block;
				float: left;
				height: auto;
				width: 100%;
				background-color: black;
				color: white;
			}
			div.options{
				height: 100%;
				display: flex;
				flex-direction: column;
			}
			div.charlist{
				flex-grow: 1;
				overflow-y: auto;
				height: calc(100% - 54px);
			}
			div.character{
				padding: 5 0 5 0;
			}
			div.chargroup{
				padding: 5 0 5 0;
				cursor: default;
				-webkit-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
			}
			.group{
				font-size: 20px;
				font-weight: bold;
			}
			div.derivative{
				height:50px;
				line-height: 50px;
			}
			div.derivative span{
				pointer-events: none;
				height:50px;
				width: calc(100% - 50px);
				margin: 0;
				border: 0;
				color: white;
				display: inline-block;
				vertical-align: middle;
				line-height: normal;
			}
			div.action, div.dice, div.log, div.narration {
				font-weight: bold;
			}
			div.narration {
				text-align: center;
			}
			div.whisper{
				font-size: 12px;
			}
			div.system {

			}
			div#OI{
				height: 100%;
				max-width: calc(100% - 10px);
			}
			div#left{
				max-width: calc(100% - 10px);
			}
			div#IC, div#OOC{
				max-height: calc(100% - 10px);
			}
			div.OOCbox{
				overflow-y: auto;
				height: 100%;
			}
			div.ICbox{
				overflow-y: auto;
				height: 100%;
			}
			input {
				background-color: white;
				color: black;
				border: 0;
			}
			input.OOCbar {
				background-color: red;
				color: black;
				height: 15px;
			}
			input.OOCbar:focus {
				outline-width: 0;
			}
			ul.tab{
			    list-style-type: none;
			    margin: 0;
			    padding: 0;
			    overflow: hidden;
			    background-color: black;	
			}
			ul.tab li {
				transition: 0.3s;
			}
			ul.tab li:hover{background-color: #555;}
			ul.tab li div{
				text-align: center;
				border: 1px solid #333;
				cursor: default;
				font-size: 10pt;
				display: inline-block;
				color: white;
				transition: 0.3s;
				background-color: black;
				-webkit-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
			}
			ul.tab li div:hover{background-color: #555;}
			.gutter {
				background-color: #d3d3d3;
			}
			.gutter.gutter-horizontal{
				height: 100%;
				cursor: ew-resize;
			}
			.gutter.gutter-vertical{
				cursor: ns-resize;
			}
			.modalContainer{
				z-index: 1;
				position: fixed;
				pointer-events: none;
				background: none;
			}
			.modal {
				pointer-events: auto;
				z-index: 1;
				position: fixed;
				display: block;
				width: auto;
				overflow: auto;
				background-color: rgb(0,0,0);
				background-color: rgba(50,50,50,0.8);
			}
			div.contextMenu{
				z-index: 1000;
				position: fixed;
				width: auto;
			}
			div.contextOption{
				border: 1px solid #333;
				transition: 0.3s;
				padding: 0 5;
				float: none;
				cursor: default;
				width: auto;
				-webkit-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
			}
			div.contextOption:hover{
				background-color: #555;
			}
			div.PLentry{
				text-align: center;
				cursor: default;
				-webkit-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
			}
			.Command{
				border: 0;
				padding: 2 0;
				color: #d3d3d3;
				transition: 0.3s;
				cursor: pointer;
				-webkit-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
			}
			input[type=number]::-webkit-outer-spin-button,input[type=number]::-webkit-inner-spin-button{
				-webkit-appearance: none;
				margin: 0;
			}
			input[type=number]{
				-moz-appearance: textfield;
				margin: 0;
			}
			input.char, select.char{
				float: right;
				width: 60%;
				padding: 0;
				border: 0;
				height:17px;
			}
			.Command:hover{
				color: white;
			}
			canvas {
			    image-rendering: crisp-edges;
			    image-rendering: -moz-crisp-edges;
			    image-rendering: -webkit-optimize-contrast;
			    image-rendering: -o-crisp-edges;
			    -ms-interpolation-mode: nearest-neighbor;
			}
		</style>
	</head>
	<body>
		<div id="main"></div>

		<script src="/socket.io/socket.io.js"></script>
		<script src="http://www.myersdaily.org/joseph/javascript/md5.js"></script>
		<script src="http://nathancahill.github.io/Split.js/split.js"></script>
		<script src="https://cdn.rawgit.com/viliusle/Hermite-resize/master/dist/hermite.js"></script>
		<script src="http://www.lalit.org/wordpress/wp-content/uploads/2008/05/fontdetect.js"></script>
		<script src="https://unpkg.com/react@15.3.2/dist/react.js"></script>
		<script src="https://unpkg.com/react-dom@15.3.2/dist/react-dom.js"></script>
		<script src="https://unpkg.com/babel-core@5.8.38/browser.min.js"></script>
		<script type="text/babel">
		var socket = io();

		var Outercontainer = React.createClass({
			getInitialState: function(){
				return {settings: {}, characters: [], modal: [{type: 'login'}], permissions: 'Guest', username: '', pass: '', players: {}};
			},

			componentDidMount: function(){
				var that = this;
				Split(['#left', '#OI'], {
					minSize: [0, 0]
				});
				Split(['#IC', '#OOC'], {
					direction: 'vertical',
					minSize: [0, 0]
				});
				//Admittedly a bit of a cheesey workaround, but Split.js gives me a lot of useful functionality and until it fixes the fact that it sets them to static pixel values when I use sizes: [20, 80] I gotta do it SOMEHOW.
				//If split.js ever breaks on me I'll probably code the sliders based on it instead of dealing with it including that bug, but it isn't worth the effort right now.
				document.getElementById('left').style.width = "calc(25% - 5px)";
				document.getElementById('OI').style.width = "calc(75% - 5px)";
				this.props.socket.on('PlayerList', function(players){
					that.setState({players: players, permissions: players[that.state.username].permissions});
				});
				this.props.socket.on('reconnect', function(){
					if(that.state.username){
						that.props.socket.emit('login', that.state.username, that.state.pass, function(res){
							if(res.settings){
								that.handleSettings(res.settings, res.characters);
							} else {
								console.log(res);
							}
						});
					}
				});
			},

			closeModal: function(n){
				var modal = this.state.modal;
				modal[n] = undefined;//would use delete, but I need the indices to stay in order.
				this.setState({modal: modal});
			},

			handleEnter: function(e){
				if(e.key === 'Enter'){
					//placeholder test function, will be added to the options menu later.
					if(this.refs.OOCbar.value.startsWith("/setcolor ")){
						var set = this.state.settings;
						set.textcolor = this.refs.OOCbar.value.split(" ")[1];
						this.setState({settings: set});
					}
					this.props.socket.emit('OOCmessage', this.refs.OOCbar.value, this.state.settings.textcolor);
					this.refs.OOCbar.value = '';
				}
			},

			handleSettings: function(settings, characters){
				this.setState({settings: settings, characters: characters});
				this.props.socket.emit('save', JSON.stringify({settings: settings, characters: characters}));
			},

			setUser: function(name, pass){
				this.setState({username: name, pass: pass});
			},

			contextMenu: function(e){
				var target = e.target;
				e.preventDefault();
				e.stopPropagation();
				//TODO: see if you can somehow combine the context menus to show all relevant options for a given rightclick and link them properly to their targets.
				var options = target.getAttribute('data');
				while(!options && target.parentNode.getAttribute('id') != 'main'){
					target = target.parentNode;
					options = target.getAttribute('data');
				}
				if(options){
					var position = {x: e.nativeEvent.clientX, y: e.nativeEvent.clientY};
					options = options.split(",");//a list of the option names
					var processed = [];
					var that=this;
					options.forEach(function(option, index){
						var check = option.split('*');
						var ret = check.shift();
						check = check[0];
						if(check){//option has a condition
							if((check == 'admin' && that.state.permissions == 'Admin'
								|| check == 'player' && ['Player', 'Admin'].indexOf(that.state.permissions) > -1)
								|| check == that.state.username){
								processed.push(ret);
							}
						} else {
							processed.push(ret);
						}
					});
					if(processed.length){
						this.setState({context: {position: position, options: processed, target: target}});
					}
				}
			},

			handleContext: function(e){
				var name = e.target.textContent;
				var id = this.state.context.target.getAttribute('id').split(',');
				var newmodal = {id: id, name: name};
				if(id.length >= 2 && name != 'Whisper'){
					newmodal.charid = this.state.characters[id[0]][id[1]][0].id;
					if(id.length === 3){
						var deriv = this.state.characters[id[0]][id[1]][id[2]];
						newmodal.icpos = {left: deriv.icpos.left, top: deriv.icpos.top};
					}
				}
				switch(name){
					case 'Delete'://just delete it outright.
						var settings = this.state.settings;
						settings.dice.splice(+id[0].substring(4), 1);
						this.handleSettings(settings, this.state.characters);
						break;
					case 'Delete Group':
						newmodal.groupname = this.state.characters[id[0]][0];
						//fallthrough
					case 'Delete Character'://fallthrough
					case 'Delete Derivative':
						newmodal.type = 'delete';
						break;
					case 'Create Derivative'://fallthrough
					case 'Edit Derivative':
						//fallthrough
					case 'New Character':
						newmodal.type = 'character';
						break;
					case 'Edit Group':
						newmodal.groupname = this.state.characters[id[0]][0];
						//fallthrough
					case 'New Group':
						newmodal.type = 'group';
						break;
					case 'Edit':
						var children = this.state.context.target.children;
						newmodal.post = children[children.length-1].innerHTML;
						if(newmodal.post.charAt(0) === '"'){//This is really a bad check.
							newmodal.post = newmodal.post.slice(1, -1);
						}
						if(newmodal.post.endsWith(" (Edited)")){
							newmodal.post = newmodal.post.slice(0, -9);
						}
						newmodal.post = newmodal.post.replace(/<br( \/)?>/g, '\n');
						//fallthrough
					case 'Whisper':
						newmodal.id = id.join(',');//doesn't harm edit as long as you make modata.id[0] into modata.id there, it should only be one number
						//fallthrough
					case 'Say':
						//fallthrough
					case 'Action':
						//fallthrough
					case 'Omit Say':
						//fallthrough
					case 'Omit Action':
						//fallthrough
					case 'Test Say':
						//fallthrough
					case 'Test Action':
						//fallthrough
					case 'Join Room':
						newmodal.type = 'action';
						break;
					case 'Set Profile':
						var that=this;
						this.props.socket.emit('Show Profile', newmodal.charid, function(response){
							newmodal.post = response.replace(/<br( \/)?>/g, '\n');
							newmodal.type = 'action';
							that.modalpush(newmodal);//async is just fine thanks to this function.
						});
						break;
					case 'Leave Room':
						var settings = this.state.settings;
						var rooms = Object.keys(settings.rooms);
						var ind = -1;
						for(var i=0; i < rooms.length && ind < 0; i++){//stop if we find it
							ind = settings.rooms[rooms[i]].indexOf(newmodal.charid);
						}
						if(ind > -1){//it's in this room
							i--;
							settings.rooms[rooms[i]].splice(ind, 1);
							if(settings.rooms[rooms[i]].length < 1){
								this.props.socket.emit('Leave Room', rooms[i]);
								delete settings.rooms[rooms[i]];
							}
						}
						this.handleSettings(settings, this.state.characters);
						break;
					case 'Ban':
						//fallthrough
					case 'Boot':
						//fallthrough
					case 'Make Player':
						//fallthrough
					case 'Make Admin':
						//fallthrough
					case 'Make Guest':
						this.props.socket.emit('AdminCommand', name, id.join(','));
						break;
					default:
						console.log('Unrecognized context command.');
				}
				this.modalpush(newmodal);
			},

			modalpush: function(data){//helper for putting new modals in. Also good for letting other components do it.
				if(data && data.id && data.type && data.name){
					var mod = this.state.modal;
					var i=0;
					while(mod[i]){//until we find one that's undefined
						i++;
					}//we leave the loop when mod[i] is undefined, so...
					mod[i] = data;
					this.setState({modal: mod});//if mod isn't changed it probably won't even update, and if it does the difference will be irrelevant.
				}
			},

			closeContext: function(e){
				//this function just tells the context menu to close if you click literally anything.
				this.setState({context: null});
			},

			render: function(){//whenever I need bottom space I can tell left and IO to have their height as 100% - (however many pixels)
				var context = <div className='contextMenu' style={{display: 'none'}}></div>;
				if(this.state.context){
					var that = this;
					var options = this.state.context.options.map(function(op, i){
						return(<div key={i} className='contextOption' onClick={that.handleContext}>{op}</div>);
					});
					if(this.state.context.position.y > (0.75*window.innerHeight)){
						context = (<div className='contextMenu' style={{left: this.state.context.position.x+'px', bottom:(window.innerHeight-this.state.context.position.y)+'px'}}>{options}</div>);
					} else {
						context = (<div className='contextMenu' style={{left: this.state.context.position.x+'px', top:this.state.context.position.y+'px'}}>{options}</div>);
					}
				}

				return (
					<div style={{height: "calc(100vh - 15px)"}} onContextMenu={this.contextMenu} onClick={this.closeContext}>
						<ModalHandler socket={this.props.socket} handleSettings={this.handleSettings} setUser={this.setUser} modal={this.state.modal} closeModal={this.closeModal} characters={this.state.characters} settings={this.state.settings}/>
						{context}
						<div id="left">
							<ChartabHandler socket={this.props.socket} handleSettings={this.handleSettings} characters={this.state.characters} settings={this.state.settings} players={this.state.players} modalpush={this.modalpush} permissions={this.state.permissions} systemmessage={this.refs.OOCbox ? this.refs.OOCbox.systemmessage : null}/>
						</div>
						<div id="OI">
							<div id="IC">
								<IChandler socket={this.props.socket}/>
							</div>
							<div id="OOC">
								<OOChandler ref="OOCbox" socket={this.props.socket}/>
							</div>
						</div>
						<input className="OOCbar" style={{width: '100%', padding: '0 0 0 0', border: '0'}} type="text" ref="OOCbar" placeholder="Input an OOC message" onKeyPress={this.handleEnter}/>
					</div>
				);
			}
		});

		var ModalHandler = React.createClass({
			getInitialState: function(){
				return {positions: [], currentDrag: null, loginmessage: 'Please input a username and password of at least 6 characters.'};
			},

			submission: function (e){
				var type = e.target.getAttribute('id');
				e.preventDefault();
				var that=this;
				var username = this.refs.username.value;
				var password = this.refs.password.value;
				if(username.length >= 6 && password.length >= 6){
					var ind = e.target.parentNode.getAttribute('id');
					this.props.socket.emit(type, username, md5(password), function (response){
						if(response.settings){
							that.props.handleSettings(response.settings, response.characters);
							that.props.setUser(username, md5(password));
							that.closeModal(ind);
						} else {
							that.setState({loginmessage: response.code || response});
						}
					});
				}
			},

			startDrag: function(e){
				if(e.target.getAttribute('class') == "modal"){//only START for the modal containers.
					e.stopPropagation();
					e.preventDefault();
					this.setState({currentDrag: e.target.getAttribute('id'), initialposition: {x: e.nativeEvent.offsetX, y: e.nativeEvent.offsetY}});
					document.addEventListener('mousemove', this.drag);
					document.addEventListener('mouseup', this.stopDrag);
				}
			},

			drag: function(e){
				e.stopPropagation();
				e.preventDefault();
				var pos = this.state.positions;
				var initpos = this.state.initialposition;
				var x = e.clientX-initpos.x;
				var y = e.clientY-initpos.y;
				var rect = this.refs[this.state.currentDrag].getBoundingClientRect();
				if(x < 0){x=0;} if(y < 0){y=0;}
				if(x+rect.width > document.body.clientWidth){x=document.body.clientWidth-rect.width;}
				if(y+rect.height > document.body.clientHeight){y=document.body.clientHeight-rect.height;}
				pos[this.state.currentDrag] = {x: x, y: y};
				this.setState({positions: pos});
			},

			stopDrag: function(e){
				e.stopPropagation();
				e.preventDefault();
				this.setState({currentDrag: null});
				document.removeEventListener('mousemove', this.drag);
				document.removeEventListener('mouseup', this.stopDrag);
			},

			handleFIs: function(e){
				var list = e.target.files;
				var id = e.target.parentNode.getAttribute('id');//current index
				var img = [];
				for(var i=0; i<list.length; i++){
					if (list[i].type.match(/image.*/)) {
						img.push(window.URL.createObjectURL(list[i]));
					};
				}
				var images = this.state.images || [];
				images[id] = img;
				this.setState({images: images});
			},

			enterCheck: function(e){
				if(e.keyCode == 13 && !e.shiftKey){//hit enter
					this.post(e);
				}
			},

			post: function(e){
				var modal = e.target.parentNode;
				var id = modal.getAttribute('id');
				var modata = this.props.modal[id];
				var post = this.refs['text'+id].value;
				if(modata.name == 'Set Room'){//should allow null
						if(this.props.settings.room && !this.props.settings.rooms[this.props.settings.room]){//we were in a room and we have no characters in it
							this.props.socket.emit('Leave Room', this.props.settings.room);
						}
						this.props.settings.room = post;
						if(post){
							this.props.socket.emit('Join Room', post);
						}
						this.props.handleSettings(this.props.settings, this.props.characters);
				} else if(post){
					if(modata.name == 'Edit'){
						if(modata.post != post){
							this.props.socket.emit('ICedit', post, modata.id);
						}
					} else if(modata.name == 'Whisper'){
						this.props.socket.emit('Whisper', post, modata.id);
					} else if(modata.name == 'Narrate'){
						this.props.socket.emit('Narrate', post, this.props.settings.textcolor, this.props.settings.room);
					} else if(['Edit Rules', 'Edit MOTD', 'Edit Default Profile', 'Edit World Info'].indexOf(modata.name) > -1){
						this.props.socket.emit(modata.name, post);
					} else if(modata.name == 'Set Profile'){
						this.props.socket.emit(modata.name, post, modata.charid);
					} else if(modata.name == 'Join Room'){
						var settings = this.props.settings;
						if(!settings.rooms[post]){//not in this room yet
							this.props.socket.emit('Join Room', post);
							settings.rooms[post] = [];
						}
						//need to remove them from their previous room too if applicable
						var rooms = Object.keys(settings.rooms);
						var ind = -1;
						for(var i=0; i < rooms.length && ind < 0; i++){//stop if we find it
							ind = settings.rooms[rooms[i]].indexOf(modata.charid);
						}
						if(ind > -1){//it's in this room
							i--;
							settings.rooms[rooms[i]].splice(ind, 1);
							if(settings.rooms[rooms[i]].length < 1){
								this.props.socket.emit('Leave Room', rooms[i]);
								delete settings.rooms[rooms[i]];
							}
						}
						settings.rooms[post].push(modata.charid);
						this.props.handleSettings(settings, this.props.characters);
					} else {//find the right id
						var trueid = this.verifyID(modata.charid, modata.id, modata.icpos);
						var room = null;
						if(modata.name == 'Say' || modata.name == 'Action'){//only for IC posts.
							var rooms = Object.keys(this.props.settings.rooms);
							for(var i=0; i < rooms.length && !room; i++){
								if(this.props.settings.rooms[rooms[i]].indexOf(modata.charid) > -1){//it's in this room
									room = rooms[i];
								}
							}
						}
						if(trueid){
							var deriv = this.props.characters[trueid[0]][trueid[1]][trueid[2]];
							this.props.socket.emit('characterPost', post, deriv, modata.name, room);
						}//if it's undefined the character doesn't exist.
					}
				}

				this.closeModal(id);
			},

			verifyID: function(charid, id, icpos){
				var i, j, k;
				var characters = this.props.characters;
				if(characters[id[0]] && (id[0] == 0 && characters[0][0] || characters[id[0]][1])){//group exists and isn't empty.
					if(characters[id[0]][id[1]] && characters[id[0]][id[1]][0].id == charid){//id is occupied by the right character
						if(icpos && (!(characters[id[0]][id[1]][id[2]].icpos.left == icpos.left) || !(characters[id[0]][id[1]][id[2]].icpos.top == icpos.top))){
							for(k=0; k < characters[id[0]][id[1]].length; k++){//for each deriv in char
								if(characters[id[0]][id[1]][k].icpos.left == icpos.left && characters[id[0]][id[1]][k].icpos.top == icpos.top){//same deriv position
									return [id[0], id[1], k];
								}
							}
							return null;
						} else {
							return id;
						}
					} else {//wrong character or wrong length
						for(i=0; i < characters[id[0]].length; i++){//for each char in group
							if(characters[id[0]][i][0].id == charid){
								if(icpos && (!(characters[id[0]][i][id[2]].icpos.left == icpos.left) || !(characters[id[0]][i][id[2]].icpos.top == icpos.top))){
									for(k=0; k < characters[id[0]][i].length; k++){//for each deriv in char
										if(characters[id[0]][i][k].icpos.left == icpos.left && characters[id[0]][i][k].icpos.top == icpos.top){//same deriv position
											return [id[0], i, k];
										}
									}
									return null;//do not check other characters if this fails.
								} else {//non-derivative or derivative matches
									return [id[0], i, id[2]];
								}
							}
						}
					}
				}//group doesn't exist, is empty, or doesn't contain the character
				for(i=0; i < characters.length; i++){//for each group ([i]) in charlist
					if(characters[i] != id[0]){//again, doesn't exist, is empty, or doesn't contain it.
						for(j=0; j < characters[i].length; j++){//for each char ([i][j]) in group
							if(characters[i][j][0].id == charid){
								if(icpos && (!(characters[i][j][id[2]].icpos.left == icpos.left) || !(characters[i][j][id[2]].icpos.top == icpos.top))){
									for(k=0; k < characters[i][j].length; k++){//for each deriv in char
										if(characters[i][j][k].icpos.left == icpos.left && characters[i][j][k].icpos.top == icpos.top){//same deriv position
											return [i, j, k];
										}
									}
									return null;//do not check other characters if this fails.
								} else {//non-derivative or derivative matches
									return [i, j, id[2]];
								}
							}
						}
					}
				}
			},

			testFont: function(e){
				try{
					var d = new Detector();
					if(!e.target.value){
						e.target.style['outline-color'] = '#777'
					} else {
						if(d.detect(e.target.value)){
							e.target.style['outline-color'] = '#0f0';
							e.target.style.fontFamily = e.target.value;
						} else {
							e.target.style['outline-color'] = '#f00';
						}
					}
				} catch(err){
					e.target.style['outline-color'] = '#777';
				}
			},

			fontTest: function(e){
				if(e.ctrlKey && e.keyCode == 66){
					if(e.target.style.fontWeight == 'bold'){
						e.target.style.fontWeight = 'normal';
					} else {
						e.target.style.fontWeight = 'bold';
					}
					
				}
			},

			closeChar: function(id){
				var images = this.state.images;
				if(images){
					images[id] = null;
					this.setState({images: images});
				}
				this.closeModal(id);
			},

			charDelete: function(e){
				var modal = e.target.parentNode;
				var id = modal.getAttribute('id');
				var modata = this.props.modal[id];
				var trueid;
				//modata.id contains the ids involved.
				var characters = this.props.characters.slice();
				if(modata.id.length === 1){//group delete
					if((characters[modata.id[0]] && modata.groupname == characters[modata.id[0]][0])){//the name hasn't changed
						var salvage = characters.splice(modata.id[0], 1)[0];
						salvage.shift();//remove the name
						salvage.forEach(function(slv){
							characters[0].push(slv);
						});//add the characters to the ungrouped section.
					}
				} else if(modata.id.length === 2 || characters[modata.id[0]][modata.id[1]].length == 1){//character delete
					trueid = this.verifyID(modata.charid, modata.id, modata.icpos);
					if(trueid){
						characters[trueid[0]].splice(trueid[1], 1);
						//have to remove it from the room as well
						var rooms = Object.keys(this.props.settings.rooms);
						var ind = -1;
						for(var i=0; i < rooms.length && ind < 0; i++){
							ind = this.props.settings.rooms[rooms[i]].indexOf(modata.charid);
						}
						if(ind > -1){
							i--;
							this.props.settings.rooms[rooms[i]].splice(ind, 1);
							if(this.props.settings.rooms[rooms[i]].length < 1){
								this.props.socket.emit('Leave Room', rooms[i]);
								delete this.props.settings.rooms[rooms[i]];
							}
						}
					}
					//tell it to delete the profile too.
					this.props.socket.emit('Delete Profile', modata.charid);
				} else {
					trueid = this.verifyID(modata.charid, modata.id, modata.icpos);
					if(trueid){
						characters[trueid[0]][trueid[1]].splice(trueid[2], 1);
					}
				}
				this.props.handleSettings(this.props.settings, characters);
				this.closeModal(id);
			},

			charEdit: function(e){
				var modal = e.target.parentNode;//the modal containing the save button
				var id = modal.getAttribute('id');//I'll be using this frequently, so I'd best.
				var name = this.refs['name'+id].value;
				var icons = this.refs['faceicons'+id].children;
				if(name || this.props.modal[id].id.length > 1){//do nothing if they didn't put a name in if it's new
					var fontStyle = this.refs['font'+id].value;
					var nameColor = this.refs['nameColor'+id].value;
					var customHTML = this.refs['html'+id].value;
					var color = this.refs['color'+id].value;
					var canvas = this.refs['canvas'+id];
					var ctx = canvas.getContext('2d');
					var convertedicons = [];
					var hermi = true;
					try{
						var hermite = new Hermite_class();
					} catch(err){
						console.log("Hermite interpolation not working, quality may suffer.");
						hermi = false;
					}
					var spritecanvas = document.createElement('canvas');
					var gridsize = Math.ceil(Math.sqrt(icons.length));//smallest fitting square
					spritecanvas.width=gridsize*50; spritecanvas.height=gridsize*50;
					var spritectx = spritecanvas.getContext('2d');
					var x, y;
					for(var i=0; i<icons.length; i++){
						if(hermi){
							var h = icons[i].naturalHeight;
							var w = icons[i].naturalWidth;
							canvas.width = w; canvas.height=h;
							ctx.drawImage(icons[i], 0, 0);
							hermite.resample_single(canvas, 50, 50, true);
						} else {
							canvas.width=50; canvas.height=50;
							ctx.drawImage(icons[i], 0, 0, 50, 50);
						}
						x = (i%gridsize)*50;
						y = Math.floor(i/gridsize)*50;//thought it'd default to integer, but...
						spritectx.drawImage(canvas, x, y);//don't need 50x50 again, it won't be scaled.
						convertedicons.push({left: x, top: y});
					}
					var that=this;

					this.props.socket.emit('sendimage', spritecanvas.toDataURL("image/png"), function(picid, un){
						var modata = that.props.modal[id];
						var settings = that.props.settings;
						var characters = that.props.characters;
						var character;
						var trueid = [];
						if(modata.id.length === 1){//new char only
							trueid[0] = that.refs['group'+id].value;
							trueid.push(characters[trueid[0]].length);//put it at the end of the group
							character = [];
						} else {//i1 is group, i2 is character
							trueid = that.verifyID(modata.charid, modata.id, modata.icpos);
							if(trueid){
								character = characters[trueid[0]][trueid[1]];
							}
						}
						if(modata.id[2]){//only in the edit case (we have a deriv) do we NOT add.
							var deriv = character[trueid[2]];
							character[trueid[2]] = {id: deriv.id, name: name || deriv.name, icon: picid || deriv.icon, icpos: convertedicons[0] || deriv.icpos, nameColor: nameColor, color: color, fontStyle: fontStyle || deriv.fontStyle, customHTML: customHTML};
						} else {//but in the add derivatives case we use the 0-ID.
							var charid = character[0] ? character[0].id : un+'-'+settings.characterIDs++;
							for(i=0; i<convertedicons.length; i++){
								character.push({id: charid, name: name || character[0].name, icon: picid, icpos: convertedicons[i], nameColor: nameColor, color: color, fontStyle: fontStyle, customHTML: customHTML});
							}

						}//now we've added all the new derivatives or just modified the one.
						characters[trueid[0]][trueid[1]] = character;//adds new if new, otherwise overwrites
						that.props.handleSettings(settings, characters);
						that.props.socket.emit('Update Character', character[0]);
						that.closeChar(id);
					});
				}
				
			},

			groupEdit: function(e){
				var modal = e.target.parentNode;//the modal containing the save button
				var id = modal.getAttribute('id');
				var name = this.refs['name'+id].value;
				if(name){
					var modata = this.props.modal[id];
					var characters = this.props.characters.slice();
					var checks = [].slice.call(this.refs['chars'+id].children);
					if(!modata.name.startsWith('Edit') || (characters[modata.id[0]] && modata.groupname == characters[modata.id[0]][0])){//the name hasn't changed
						var group = modata.name.startsWith('Edit') ? characters[modata.id[0]] : [];
						group[0] = name;
						//move the selected characters
						var n = [];
						checks.forEach(function(chr, index){
							if(chr.style.fontWeight == 'bold'){//selected
								group.push(characters[0][index]);
							} else {//not selected
								n.push(characters[0][index]);
							}
						});
						characters[0] = n;//can't exactly slice them out with varying indices.
						if(modata.name.startsWith('Edit')){
							characters[modata.id[0]] = group;
						} else {
							characters.push(group);//add to end of groups
						}
						this.props.handleSettings(this.props.settings, characters);
					}
					this.closeModal(id);
				}
			},
			closeModal: function(id){
				this.state.positions[id] = null;
				this.props.closeModal(id);
				this.setState({positions: this.state.positions});
			},

			render: function(){
				var that = this;
				var modals=this.props.modal.map(function (modal, index){
					if(modal){
						var x = '25%';
						var y = '25%';
						if(that.state.positions[index]){
							x = that.state.positions[index].x+'px';
							y = that.state.positions[index].y+'px';
						}
						switch(modal.type){
							case 'login'://basically hardcoded and single-purpose.
								return(<div key={index} id={index} ref={index} className="modal" style={{textAlign:'center', height:'100%', width:'100%', paddingTop:'30px'}}>
										<input type="text" name="username" ref="username" placeholder="Username" required /><br/>
										<input type="text" name="password" ref="password" placeholder="Password" required /><br/>
										<button type="submit" id="login" onClick={that.submission}>Login</button>
										<button type="submit" id="register" onClick={that.submission}>Register</button><br/>
										<b>{that.state.loginmessage}</b><br/><br/>
										<iframe src='/worldinfo' style={{width:'95%', height:'85%'}}/>
									</div>);
							case 'character'://character creation/edit modal.
								var groupdropdown = null;
								var FIs = (<input type='file' ref={'FIs'+index} style={{width:'100%',marginBottom:'1px'}} multiple onChange={that.handleFIs}/>);//by default it allows multiple
								var nameColor; var color; var fontStyle; var customHTML;
								var character;
								var trueid;
								var name;
								if(modal.id.length == 1){//new character
									nameColor = '#ffffff';
									color = '#ffffff';
									fontStyle = 'Times New Roman';
									customHTML = '';
									var grouption = that.props.characters.map(function(group, ind){
										if(!ind){
											return (<option key={ind} value={ind}>None</option>);
										} else {
											return (<option key={ind} value={ind}>{group[0]}</option>);
										}
									});
									groupdropdown = (<select className="char" ref={'group'+index}>{grouption}</select>);
									name = modal.name;
								} else {
									trueid = that.verifyID(modal.charid, modal.id, modal.icpos);
									if(trueid){
										character = that.props.characters[trueid[0]][trueid[1]];
										nameColor = character[0].nameColor;
										color = character[0].color;
										fontStyle = character[0].fontStyle;
										customHTML = character[0].customHTML;
										name = modal.name+' - '+character[0].name;
									} else {
										that.closeChar(index);
									}
								}
								if(modal.id.length == 3){//only one FI allowed, as it's editing one derivative
									FIs = <input type='file' ref={'FIs'+index} style={{width:'100%',marginBottom:'1px'}} onChange={that.handleFIs}/>;
									color = character[trueid[2]].color || color;
									nameColor = character[trueid[2]].nameColor || nameColor;
									fontStyle = character[trueid[2]].fontStyle || fontStyle;
									customHTML = character[trueid[2]].customHTML || customHTML;
									name = modal.name+' - '+character[trueid[2]].name;
								}
								var previews = null;
								var im = that.state.images;
								if(im && im[index]){
									previews = im[index].map(function(img, index){
										return(<img src={img} key={index} width='50px' height='50px'/>);
									});
								}
								return(
									<div key={index} id={index} ref={index} className="modal" style={{left: x, top: y, width:'300px'}} onMouseDown={that.startDrag}><span className="mtitle">{name}</span><br/>
									{FIs}<br/>
									<span ref={'faceicons'+index}>{previews}</span><canvas ref={'canvas'+index} width='0' height='0'></canvas><br/>
									Name: <input type="text" className="char" ref={'name'+index} placeholder="Character Name" required style={{marginBottom:'1px'}}/><br/>
									Name Color: <input type="color" className="char" ref={'nameColor'+index} defaultValue={nameColor}/><br/>
									Text Color: <input type="color" className="char" ref={'color'+index} defaultValue={color}/><br/>
									Font: <input type="text" className="char" ref={'font'+index} placeholder="Font Style" defaultValue={fontStyle} style={{fontFamily: fontStyle}} onChange={that.testFont} onKeyDown={that.fontTest}/><br/>
									Custom HTML: <input type="text" className="char" ref={'html'+index} placeholder="Custom HTML" defaultValue={customHTML} style={{marginBottom:'1px'}}/><br/>
									{groupdropdown ? 'Select a group: ' : ''}{groupdropdown}<br/>
									<button type="submit" id="save" onClick={that.charEdit}>Save</button>
										<button type="submit" id="cancel" onClick={that.closeChar.bind(null, index)}>Cancel</button></div>
								);
							case 'group'://group creation/edit modal.
								var chars = that.props.characters[0].map(function(ch, index){
									return(<div key={'c'+index} className='Command' onClick={function(e){e.target.style.fontWeight=(e.target.style.fontWeight=='bold')? 'normal' : 'bold';}}>{ch[0].name}</div>);
								});//go through the ungrouped characters.
								var def = '';
								var name = modal.name;
								if(modal.id[0] > 0){def = that.props.characters[modal.id[0]][0]; name += ' - '+def;}
								return(<div key={index} id={index} ref={index} className="modal" style={{left: x, top: y}} onMouseDown={that.startDrag}><span className="mtitle">{name}</span><br/>
									<input type='text' ref={'name'+index} placeholder='Group Name' defaultValue={def} required style={{width:'100%'}}/><br/>
									Add characters to the group?<br/>
									<form ref={"chars"+index}>
									{chars}
									</form>
									<button type="submit" id="save" onClick={that.groupEdit}>Save</button>
										<button type="submit" id="cancel" onClick={that.closeModal.bind(null, index)}>Cancel</button>
									</div>);
							case 'delete'://'are you sure?'
								var name = modal.name;
								if(modal.groupname){name += ' - '+modal.groupname;
								} else if(modal.charid){
									var trueid = that.verifyID(modal.charid, modal.id, modal.icpos);
									if(trueid){name+=' - '+that.props.characters[trueid[0]][trueid[1]][(trueid[2] || 0)].name;} else {that.closeModal(index);}
								}
								return(
									<div key={index} id={index} ref={index} className="modal" style={{left: x, top: y}} onMouseDown={that.startDrag}><span className="mtitle">{name}</span><br/>
									Are you sure?<br/><button type="submit" onClick={that.charDelete}>Yes</button><button type="submit" onClick={that.closeModal.bind(null, index)}>No</button></div>
								);
							case 'action':
								var name = modal.name;
								if(modal.charid){
									var trueid = that.verifyID(modal.charid, modal.id, modal.icpos);
									if(trueid){name+=' - '+that.props.characters[trueid[0]][trueid[1]][(trueid[2] || 0)].name;} else {that.closeModal(index);}
								}
								return(
									<div key={index} id={index} ref={index} className="modal" style={{left: x, top: y}} onMouseDown={that.startDrag}><span className="mtitle">{name}</span><br/>
									<textarea defaultValue={modal.post || ''} autoFocus rows='4' cols='40' ref={'text'+index} onKeyDown={that.enterCheck}></textarea><br/><button type="submit" onClick={that.post}>OK</button><button type="submit" onClick={that.closeModal.bind(null, index)}>Cancel</button></div>
								);
						}
					} else {
						return(<div key={index} className="modal" style={{display:'none'}}></div>);
					}
				});
				return (
					<div className="modalContainer" style={{width:'100%', height:'100%'}}>{modals}</div>
				);
			}
		});

		var ChartabHandler = React.createClass({
			getInitialState: function(){//open.characters[ID] will be true if we need to open derivs
				return {tab: 'characters', open:{groups: {}, characters: {}}};
			},

			shiftTab: function(e){//It's both a relevant name and a terrible pun!
				this.setState({tab: e.target.getAttribute('id')});
			},


			toggleGroup: function(e){
				var op = this.state.open;
				var name = this.props.characters[e.target.getAttribute('id')][0];
				op.groups[name] = !op.groups[name];//works even on undefined!
				this.setState({open: op});
			},

			toggleChar: function(e){
				e.stopPropagation();//make sure it doesn't try to close the group
				var id = e.target.getAttribute('id').split(',');
				var op = this.state.open;
				var name = this.props.characters[id[0]][id[1]][0].id;//characters[0][2][0] for instance.
				op.characters[name] = !op.characters[name];
				this.setState({open: op});
			},

			setColor: function(e){
				var settings = this.props.settings;
				settings.textcolor = this.refs.OOCcolor.value;
				this.props.handleSettings(settings, this.props.characters);
			},

			genmodal: function(e){
				var name = e.target.textContent;
				var type = name.split(' '); type = type[type.length-1];
				var that = this;
				if(['Rules', 'MOTD', 'Profile', 'Info'].indexOf(type) > -1 && this.props.permissions == 'Admin'){
					var res = function(response){
						if(response){response = response.replace(/<br( \/)?>/g, '\n');}
						that.props.modalpush({id: [], name: name, type: 'action', post: response});
					};
					if(type == 'Profile'){
						this.props.socket.emit('Show '+type, null, res);
					} else {
						this.props.socket.emit('Show '+type, res);
					}
				} else if(['Player', 'Admin'].indexOf(this.props.permissions) > -1){//Narrate or Set Room
					this.props.modalpush({id: [], name: name, type: 'action'});
				}
			},

			gendice: function(e){
				var settings = this.props.settings;
				var dice = this.refs.Nd.value+'d'+this.refs.dN.value;
				if(this.refs.exploding.checked){dice += '!';}
				if(this.refs.Nd.value > 0 && this.refs.dN.value > 1 && ['Player', 'Admin'].indexOf(this.props.permissions) > -1){
					settings.dice.push(dice);
					this.props.handleSettings(settings, this.props.characters);
				}
			},

			show: function(e){
				this.props.socket.emit(e.target.textContent);
			},

			rooms: function(e){
				var message = '<b>Your Room</b>: '+this.props.settings.room;
				var rooms = Object.keys(this.props.settings.rooms);
				var that = this;
				var idlist = {};
				this.props.characters.forEach(function(group){
					group.forEach(function(chr, i){
						if(typeof chr !== 'string'){//skip the names
							idlist[chr[0].id] = chr[0].name;
						}
					});
				});
				rooms.forEach(function(room, j){
					message += '<br />';
					message += room + ': ';
					//add specific characters
					that.props.settings.rooms[room].forEach(function(chr, i){
						if(i){message += ', ';}//add before any character but the first
						message += idlist[chr];
					});
				});
				this.props.systemmessage(message);
			},

			roll: function(e){
				var dice = e.target.textContent.split('d');// dice[0] is the number, dice[1] is faces (plus ! if it's there)
				var result = [];
				if(dice[1].indexOf('!') > 0){//we don't know how many characters long dice[1] is.
					dice[1] = dice[1].slice(0, -1);
					dice[2] = '!';
				}
				if(dice[0]=='1' && dice[1]=='100' && dice[2]){//special case because I'm a hack.
					var open = 90;
					do{
						var roll = Math.floor(Math.random()*dice[1])+1;
						result.push(roll);
					} while (roll >= open++)//open roll window decreases each time.
				} else {
					for(var i = 0; i < dice[0]; i++){
						do {
							var roll = Math.floor(Math.random()*dice[1])+1;
							result.push(roll);
						} while (dice[2] && roll == dice[1])//explode at max
					}
				}
				this.props.socket.emit('Dice', e.target.textContent, result, this.props.settings.textcolor);
			},

			dragstart: function(e){
				e.stopPropagation();
				var handler;
				if(e.target.className == 'derivative'){handler = e.target.parentNode;} else {handler = document.getElementsByClassName('charlist')[0];}
				handler.addEventListener("dragover", this.dragover, false);
				handler.addEventListener("dragend", this.dragend, false);
				handler.addEventListener("drop", this.drop, false);
				this.setState({dragEl: e.target});
			},

			dragover: function(e){
				//make sure they're the same type but not the same element
				if(e.target.className == this.state.dragEl.className && e.target.id != this.state.dragEl.id){
					e.preventDefault();
				} else if(this.state.dragEl.className == 'character' && e.target.className.startsWith('chargroup')){
					e.preventDefault();
				}
			},

			dragend: function(e){
				var handler;
				if(e.target.className == 'derivative'){handler = e.target.parentNode;} else {handler = document.getElementsByClassName('charlist')[0];}
				handler.removeEventListener("dragover", this.dragover, false);
				handler.removeEventListener("dragend", this.dragend, false);
				handler.removeEventListener("drop", this.drop, false);
				this.setState({dragEl: null});
			},

			drop: function(e){//should only work if we prevented the default.
				var rect = e.target.getBoundingClientRect();
				var where = (e.clientY - rect.top)/(rect.bottom-rect.top) > 0.5;//if it's greater it's below
				var id1 = this.state.dragEl.id.split(',');
				var id2 = e.target.id.split(',');//length doesn't matter yet, we'll figure out what to do.
				var el;
				switch(this.state.dragEl.className){
					case 'derivative':
						el = this.props.characters[id1[0]][id1[1]].splice(id1[2], 1)[0];
						if(+id1[2] < +id2[2]){id2[2]--;}//if splice shifted the array up, account for this
						if(where){id2[2]++;}
						this.props.characters[id1[0]][id1[1]].splice(id2[2], 0, el);
						break;
					case 'character':
						el = this.props.characters[id1[0]].splice(id1[1], 1)[0];
						if(id2[1]){//no need or ability to check this otherwise
							if(id1[0] == id2[0] && +id1[1] < +id2[1]){id2[1]--;}//same group AND higher placement, or there's no shift up.
							if(where){id2[1]++;}//this needs a check regardless.
							this.props.characters[id2[0]].splice(id2[1], 0, el);
						} else {
							if(!where && id2[0] == '1'){//top group and at the top
								this.props.characters[0].push(el);//add it to the end of ungrouped.
							} else {
								this.props.characters[id2[0]].splice(1, 0, el);//add to first non-name position
							}
						}
						break;
					case 'chargroup'://no case for ungrouped, it should never be moved or draggable at all.
						el = this.props.characters.splice(id1[0], 1)[0];
						if(+id1[0] < +id2[0]){id2[0]--;}
						if(where){id2[0]++;}
						this.props.characters.splice(id2[0], 0, el);
						break;
				}
				this.props.handleSettings(this.props.settings, this.props.characters);
			},

			render: function(){
				var currenttab = null;
				var that=this;
				switch(this.state.tab){//use this to acquire the jsx for each tab
					case 'characters'://case for the characters tab
						//TODO: Consider making the [+] and [-] float right or something.
						var characters = this.props.characters;
						var charlist = characters.map(function(group, i){//groups loop
							if(i==0 || that.state.open.groups[group[0]]){//open group
								var charop = ['Create Derivative', 'Delete Character', 'Set Profile', 'Join Room*player', 'Leave Room*player'];
								var chars = characters[i].map(function(chr, i2){//characters loop
									if(typeof chr !== 'string'){//make sure it's not the name.
										if(that.state.open.characters[chr[0].id]){//open derivative list
											var derivs = characters[i][i2].map(function(deriv, i3){
												return(<div draggable data={['Edit Derivative', 'Delete Derivative', 'Say*player', 'Action*player', 'Omit Say', 'Omit Action', 'Test Say', 'Test Action']} key={i3} id={i+','+i2+','+i3} className="derivative"><img src='/faceicons/img_trans.gif' height='50px' width='50px' style={{backgroundImage: 'url(/faceicons/'+deriv.icon+'.png)', backgroundPosition: '-'+deriv.icpos.left+'px -'+deriv.icpos.top+'px', pointerEvents:'none'}}/><span>{deriv.name}</span></div>);
											});
											return(<div draggable onDragStart={that.dragstart} onClick={that.toggleChar} data={charop} key={i2} id={i+','+i2} className="character"><span style={{pointerEvents:'none'}}>{chr[0].name} [-]</span>{derivs}</div>);
										} else {//closed derivative list
											return(<div draggable onClick={that.toggleChar} data={charop} key={i2} id={i+','+i2} className="character"><span style={{pointerEvents:'none'}}>{chr[0].name} [+]</span></div>);
										}
									}
								});
								if(typeof group[0] === 'string'){//actual group
									return(<div draggable onClick={that.toggleGroup} data={['New Character', 'Edit Group', 'Delete Group']} key={i} id={i} className="chargroup"><span style={{pointerEvents:'none'}} className='group'>{group[0]} [-]</span>{chars}</div>);
								} else {//ungrouped
									return(<div id={0} data={['New Character', 'New Group']} key={i} className="chargroup ungrouped">{chars}</div>);
								}
							} else {//closed group
								return(<div draggable onClick={that.toggleGroup} data={['New Character', 'Edit Group', 'Delete Group']} key={i} id={i} className="chargroup"><span className='group' style={{pointerEvents:'none'}}>{group[0]} [+]</span></div>);
							}
						});
						if(characters.length == 1 && characters[0].length == 0){//none
							charlist = [<div id={0} data={['New Character', 'New Group']} key={0} className="chargroup ungrouped">Right-click to create a character!</div>];
						}
						currenttab = (<div id={0} onDragStart={that.dragstart} data={['New Character', 'New Group']} className="charlist">
							{charlist}
							</div>);
						break;
					case 'players'://case for the players online tab
						var players = this.props.players;
						currenttab = Object.keys(players).map(function(player, index){
							return (<div id={player} key={index} data={['Whisper', 'Make Player*admin', 'Make Admin*admin', 'Make Guest*admin', 'Boot*admin', 'Ban*admin']} className='PLentry'>{player + ' - ' + players[player].permissions}</div>);
						});
						break;
					case 'commands'://case for player commands tab
						currenttab = [<div key='0' className='Command'><span>Set Text Color</span><input type="color" ref="OOCcolor" style={{backgroundColor: 'black'}} onChange={this.setColor} defaultValue={this.props.settings.textcolor}/></div>, <div key='1' className='Command' onClick={function(e){window.open('/logs');}}>Open Logs</div>, <div key='2' className='Command' onClick={function(e){window.open('/database');}}>Open Database</div>, <div key='3' className='Command' onClick={function(e){window.open('/characters');}}>Open Character Database</div>, <div key='4' className='Command' onClick={this.genmodal}>Narrate</div>, <div key='5' className='Command' onClick={this.show}>Show Rules</div>, <div key='6' className='Command' onClick={this.show}>Show MOTD</div>, <div key='7' className='Command' onClick={function(e){window.open('/worldinfo');}}>Show World Info</div>, <div key='8' className='Command' onClick={this.rooms}>Show Rooms</div>, <div key='9' className='Command' onClick={this.genmodal}>Set Room</div>, <div key='10' className='Diceee'><span onClick={this.gendice} className='Command'>Create Dice</span> <input type="number" ref='Nd' min="1" style={{width: '10%', textAlign: 'center'}}/>d<input type="number" ref='dN' min="1" style={{width: '10%', textAlign: 'center'}}/><input type='checkbox' ref='exploding'/>!</div>];
						var that = this;
						this.props.settings.dice.forEach(function(dice, index){
							currenttab.push(<div key={11+index} id={'Dice'+index} data={['Delete']} className='Dice Command' onClick={that.roll}>{dice}</div>);
						});
						break;
					case 'admin'://case for the administrative commands tab
						currenttab = [<div key='0' className='Command' onClick={this.genmodal}>Edit Rules</div>, <div key='1' className='Command' onClick={this.genmodal}>Edit MOTD</div>, <div key='2' className='Command' onClick={this.genmodal}>Edit Default Profile</div>, <div key='3' className='Command' onClick={this.genmodal}>Edit World Info</div>]
				}
				var admin = this.props.permissions=='Admin'? <li><div className="tablink" id="admin" onClick={this.shiftTab}>Admin Commands</div></li> : null;
				return (
					<div className="options">
						<ul className="tab" style={{listStyleType:'none'}}>
							<li><div className="tablink" id="characters" onClick={this.shiftTab}>Characters</div></li>
							<li><div className="tablink" id="players" onClick={this.shiftTab}>Players Online</div></li>
							<li><div className="tablink" id="commands" onClick={this.shiftTab}>Player Commands</div></li>
							{admin}
						</ul>
						{currenttab}
					</div>
				);
			}
		});

		var Message = React.createClass({

			htmlupdate: function(){//modify content to innerHTML
				var message = this.props.message;
				var classparam = message.className.split(" ")[1];
				var post = message.post;
				if(this.refs.post){
					switch(classparam){
						case 'say':
							post = '"'+post+'"';
							if(message.className.startsWith('O')){//omit
								post += ' <b>(Omit)</b>';
							}
							break;
						case 'action':
							if(message.className.startsWith('O')){//omit
								post += ' (Omit)';
							}
					}
					this.refs.post.innerHTML = post;
				}
				if(this.refs.name && message.character.customHTML){//only for character posts
					var name = message.character.customHTML || message.character.name;
					switch(classparam){
						case 'say':
							name += ':';
						case 'action':
							name += ' ';
					}
					this.refs.name.innerHTML = name;
				}
			},

			componentDidMount: function(){
				this.htmlupdate();
			},

			componentDidUpdate: function(){
				this.htmlupdate();
			},

			render: function(){
				var message = this.props.message;
				var character = message.character;//worst case it's just null and then it won't be getting used anyway.
				var classparam = message.className.split(" ")[1];
				switch(classparam){
					case 'message'://ooc message
						return (<div className={message.className}>( <b>{message.username+': '}</b><span ref="post" style={{color: message.color}}></span> ){'\r'}</div>);
					case 'whisper'://ooc whisper
						return (<div className={message.className}>( <b>{message.username+' sent you a message: '}</b><span ref="post"></span> ){'\r'}</div>);
					case 'narration'://ic narration message
						return (<div id={message.id} data={'Edit*'+message.username} className={message.className}><span ref="post" style={{color: message.color}}></span>{'\r'}</div>);
					case 'dice'://ooc dice message
						return (<div className={message.className}><span ref="post" style={{color: message.color}}></span>{'\r'}</div>);
					case 'log':
						return (<div className={message.className}>{"| "+message.username+" "+message.post+" |"}{'\r'}</div>);
					case 'system'://just the post itself.
						return (<div className={message.className}><span ref="post"></span>{'\r'}</div>);
					case 'say':
						character.name +=':';
					case 'action':
						var charid = character.id.split('-');
						var d = charid.pop();
						charid = charid.join('-');//catches names with - in them
						var profileopen = function(e){window.open('/characters/'+charid+'/'+d+'.html');}
						var edit = '';
						if(message.id){edit = 'Edit*'+charid;}//worst case message.id is undefined
						return(<div id={message.id} data={edit} className={message.className} style={{fontFamily: character.fontStyle}}><img src='/faceicons/img_trans.gif' onClick={profileopen} height='50px' width='50px' style={{cursor: 'pointer', backgroundImage: 'url(/faceicons/'+character.icon+'.png)', backgroundPosition: '-'+character.icpos.left+'px -'+character.icpos.top+'px'}}/> <span ref='name' style={{fontWeight: 'bold', color: character.nameColor}}>{character.name+' '}</span><span ref="post" style={{color: character.color}}></span>{'\r'}</div>);
				}
			}
		});

		var IChandler = React.createClass({
			getInitialState: function(){
				//normally messages would be empty but I want to test this out.
				return {messages: [], ids: {}, height: 0};
			},

			shouldComponentUpdate: function(nextProps, nextState){
				return(nextState.messages.length !== this.state.messages.length);
			},

			componentDidUpdate: function(){
				//I need it to only autoscroll if they were previously at the bottom.
				if(this.refs.box.scrollTop + this.refs.box.clientHeight >= this.state.height){
					this.refs.box.scrollTop = this.state.height;
				}
			},

			componentDidMount: function(){
				var that = this;
				this.props.socket.on('ICmessage', function(message){
					var newm = that.state.messages.slice();
					var ids = that.state.ids;
					ids[message.id] = newm.length;//index this post to its id
					newm.push(<Message key={newm.length} message={message}/>);
					that.setState({messages: newm, ids: ids, height: that.refs.box.scrollHeight});
				});

				this.props.socket.on('ICedit', function(message){
					var messages = that.state.messages.slice();
					var ids = that.state.ids;
					var target = messages[ids[message.id]];
					if(target){//if it isn't in here obviously we aren't doing it.
						var msg = target.props.message;
						msg.post = message.post;
						messages[ids[message.id]] = React.cloneElement(target, msg);
						
						that.setState({messages: messages, height: that.refs.box.scrollHeight});
						that.forceUpdate();//this is the cheap solution.
					}
				});
			},

			render: function(){
				return (
					<div ref='box' className='ICbox'>
						{this.state.messages}
					</div>
				);
			}
		});

		var OOChandler = React.createClass({
			getInitialState: function(){
				return {messages: [], height: 0};
			},

			systemmessage: function(message){
				var newm = this.state.messages.slice();
				newm.push(<Message key={newm.length} message={{post: message, className: 'OOC system message'}}/>)
				this.setState({messages: newm, height: this.refs.box.scrollHeight});
			},

			shouldComponentUpdate: function(nextProps, nextState){
				return(nextState.messages.length !== this.state.messages.length);
			},

			componentDidUpdate: function(){
				if(this.refs.box.scrollTop + this.refs.box.clientHeight >= this.state.height){
					this.refs.box.scrollTop = this.state.height;
				}
			},

			componentDidMount: function(){
				var that = this;
				this.props.socket.on('OOCmessage', function(message){
					var newm = that.state.messages.slice();
					newm.push(<Message key={newm.length} message={message}/>);
					that.setState({messages: newm, height: that.refs.box.scrollHeight});
				});
				this.props.socket.on('disconnect', function(){
					var newm = that.state.messages.slice();
					newm.push(<Message key={newm.length} message={{username: 'You', post: 'have disconnected.', className: 'OOC log message'}}/>);
					that.setState({messages: newm, height: that.refs.box.scrollHeight});
				});
			},

			render: function(){
				return (
					<div ref='box' className='OOCbox'>
						{this.state.messages}
					</div>
				);
			}
		});

		ReactDOM.render(
			<Outercontainer socket={socket}/>,
			document.getElementById('main')
		);
		</script>
	</body>
</html>